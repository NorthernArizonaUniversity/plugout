/*
Copyright 2013/2014 Northern Arizona University

This file is part of Plugout.

Plugout is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

Plugout is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with Plugout. If not, see <http://www.gnu.org/licenses/>.
*/

// Generated by CoffeeScript 1.4.0
(function() {
  var PluginManager, merge,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty;

  merge = function() {
    var k, obj, source, sources, v, _i, _len;
    obj = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      for (k in source) {
        v = source[k];
        obj[k] = v;
      }
    }
    return obj;
  };

  PluginManager = (function() {

    function PluginManager(context, pluginPath, loadPlugins) {
      this.context = context;
      this.pluginPath = pluginPath;
      if (loadPlugins == null) {
        loadPlugins = {};
      }
      this.invoke = __bind(this.invoke, this);

      this.provide = __bind(this.provide, this);

      /* Creates a new plugin manager object
      */

      if (!(this.context && this.context.emit)) {
        throw new Exception('Context object must exist and must emit events');
      }
      if (!this.pluginPath) {
        throw new Exception('Plugin path must be provided');
      }
      if (!this.pluginPath.match(/\/$/)) {
        this.pluginPath = this.pluginPath + '/';
      }
      this.plugins = {};
      this.listeners = {};
      this.provides = {};
      this.loadPlugins(loadPlugins != null ? loadPlugins : {});
    }

    PluginManager.prototype.addListeners = function(plugin) {
      /* Adds listeners to a plugin based on plugin options.
      */

      var event, key, listener, sublistener, _ref, _results;
      _ref = plugin.listeners;
      _results = [];
      for (event in _ref) {
        if (!__hasProp.call(_ref, event)) continue;
        listener = _ref[event];
        key = plugin.options.prefix + event;
        if (typeof listener === 'function') {
          this.listeners[key] = listener;
          _results.push(this.context.addListener(event, listener));
        } else {
          _results.push((function() {
            var _i, _len, _ref1, _results1;
            _results1 = [];
            for (_i = 0, _len = listener.length; _i < _len; _i++) {
              sublistener = listener[_i];
              this.listeners[key] = (_ref1 = this.listeners[key]) != null ? _ref1 : [];
              this.listeners[key].push(sublistener);
              _results1.push(this.context.addListener(event, sublistener));
            }
            return _results1;
          }).call(this));
        }
      }
      return _results;
    };

    PluginManager.prototype.removeListeners = function(plugin) {
      /* removes all listeners from the given plugin
      */

      var event, key, listener, sublistener, _i, _len, _ref, _results;
      _ref = plugin.listeners;
      _results = [];
      for (event in _ref) {
        if (!__hasProp.call(_ref, event)) continue;
        listener = _ref[event];
        key = plugin.options.prefix + event;
        listener = this.listeners[key];
        if (typeof listener === 'function') {
          this.context.removeListener(event, listener);
        } else {
          for (_i = 0, _len = listener.length; _i < _len; _i++) {
            sublistener = listener[_i];
            this.context.removeListener(event, sublistener);
          }
        }
        _results.push(delete this.listeners[key]);
      }
      return _results;
    };

    PluginManager.prototype.getPlugin = function(name) {
      /* returns the plugin object by name
      */

      var cleanName;
      cleanName = this.pluginPath + name;
      return this.plugins[cleanName];
    };

    PluginManager.prototype.callPlugin = function() {
      var args, plugin, _ref;
      plugin = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      /* Calls a function provided by a plugin. The function should be defined in module.exports.provides
      */

      return (_ref = this.getPlugin(plugin)) != null ? _ref.call.apply(this, args) : void 0;
    };

    PluginManager.prototype.loadPlugin = function(name, options) {
      /* Loads (or reloads) a plugin by name with the given options, attaches listeners and utility references.
      */

      var cleanName, full, module, pl, _base, _i, _len, _ref;
      cleanName = this.pluginPath + name;
      full = require.resolve(cleanName);
      pl = require.cache[full];
      if (pl != null) {
        if (pl.exports.reload != null) {
          _ref = pl.exports.reload;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            module = _ref[_i];
            delete require.cache[module];
          }
        }
        delete require.cache[full];
      }
      if (this.plugins[cleanName]) {
        this.unloadPlugin(name);
      }
      this.context.emit('plugin-pre-load', name);
      pl = require(full);
      this.plugins[cleanName] = pl;
      this.initPlugin(pl, name, options);
      this.addListeners(pl);
      this.context.emit('plugin-pre-init', name, pl);
      if (typeof (_base = pl.listeners).load === "function") {
        _base.load();
      }
      if (typeof pl.init === "function") {
        pl.init();
      }
      return this.context.emit('plugin-load', name, pl);
    };

    PluginManager.prototype.initPlugin = function(pl, name, options) {
      var defaultOptions, _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
        _this = this;
      pl.context = this.context;
      pl.logger = (_ref = this.context.logger) != null ? _ref : null;
      if ((_ref1 = pl.listeners) == null) {
        pl.listeners = {};
      }
      if ((_ref2 = pl.provides) == null) {
        pl.provides = {};
      }
      defaultOptions = (_ref3 = (_ref4 = this.plugins) != null ? _ref4[name] : void 0) != null ? _ref3 : {};
      options = merge(defaultOptions, options != null ? options : {});
      pl.options = merge((_ref5 = pl.defaultOptions) != null ? _ref5 : {
        path: "/" + name
      }, options);
      pl.options.prefix = name;
      pl.getContext = function() {
        return _this.context;
      };
      pl.invoke = this.invoke;
      pl.provide = this.provide;
      pl.emit = this.context.emit;
      return pl.listen = this.context.addListener;
    };

    PluginManager.prototype.unloadPlugin = function(name, options) {
      /* Unloads the given plugin.
      */

      var cleanName, pl, _base;
      cleanName = this.pluginPath + name;
      pl = this.plugins[cleanName];
      if (pl == null) {
        throw new Error("Plugin not found: " + name);
      }
      this.context.emit('plugin-pre-unload', name, pl);
      pl.options = options != null ? options : {};
      pl.options.prefix = name;
      this.removeListeners(pl);
      delete this.plugins[cleanName];
      if (typeof (_base = pl.listeners).unload === "function") {
        _base.unload();
      }
      return this.context.emit('plugin-unload', name, pl);
    };

    PluginManager.prototype.loadPlugins = function(plugins) {
      /*
          Loads multiple plugins. Plugin list should be an object
          with the plugin names as keys and plugin option objects as values.
      */

      var name, options, _results;
      _results = [];
      for (name in plugins) {
        if (!__hasProp.call(plugins, name)) continue;
        options = plugins[name];
        _results.push(this.loadPlugin(name, options));
      }
      return _results;
    };

    PluginManager.prototype.parseProvideName = function(name) {
      var matches, pl, _ref;
      matches = name.match(/^(([^.]+)\.)?(.*)/);
      pl = this.getPlugin(matches[2]);
      if (pl) {
        if ((_ref = pl.provides) == null) {
          pl.provides = {};
        }
      }
      return [pl, matches[3]];
    };

    PluginManager.prototype.provide = function(name, fn) {
      var pl, subname, _ref;
      _ref = this.parseProvideName(name), pl = _ref[0], subname = _ref[1];
      if (pl != null) {
        return pl.provides[subname] = fn;
      } else {
        return this.provides[name] = fn;
      }
    };

    PluginManager.prototype.invoke = function() {
      var args, fn, name, pl, _ref, _ref1, _ref2;
      fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.provides[fn] != null) {
        return this.provides[fn].apply(this, args);
      }
      _ref = this.parseProvideName(fn), pl = _ref[0], name = _ref[1];
      return pl != null ? (_ref1 = pl.provides) != null ? (_ref2 = _ref1[name]) != null ? _ref2.apply(pl, args) : void 0 : void 0 : void 0;
    };

    return PluginManager;

  })();

  module.exports.PluginManager = PluginManager;

}).call(this);
