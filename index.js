// Generated by CoffeeScript 1.7.1

/*
Copyright 2013/2014 Northern Arizona University

This file is part of Plugout.

Plugout is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

Plugout is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with Plugout. If not, see <http://www.gnu.org/licenses/>.
 */

(function() {
  var Plugout, merge,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty;

  merge = function() {
    var k, obj, source, sources, v, _i, _len;
    obj = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      for (k in source) {
        v = source[k];
        obj[k] = v;
      }
    }
    return obj;
  };

  Plugout = (function() {
    function Plugout(context, pluginPath, loadPlugins) {
      this.context = context;
      this.pluginPath = pluginPath;
      if (loadPlugins == null) {
        loadPlugins = {};
      }
      this.invoke = __bind(this.invoke, this);
      this.provide = __bind(this.provide, this);

      /* Creates a new plugin manager object */
      if (!(this.context && this.context.emit)) {
        throw new Exception('Context object must exist and must emit events');
      }
      if (!this.pluginPath) {
        throw new Exception('Plugin path must be provided');
      }
      if (!this.pluginPath.match(/\/$/)) {
        this.pluginPath = this.pluginPath + '/';
      }
      this.plugins = {};
      this.listeners = {};
      this.provides = {};
      this.loadPlugins(loadPlugins != null ? loadPlugins : {});
    }

    Plugout.prototype.addListeners = function(plugin) {

      /* Adds listeners to a plugin based on plugin options. */
      var event, key, listener, sublistener, _ref, _results;
      _ref = plugin.listeners;
      _results = [];
      for (event in _ref) {
        if (!__hasProp.call(_ref, event)) continue;
        listener = _ref[event];
        key = plugin.options.prefix + event;
        if (typeof listener === 'function') {
          this.listeners[key] = listener;
          _results.push(this.context.addListener(event, listener));
        } else {
          _results.push((function() {
            var _i, _len, _ref1, _results1;
            _results1 = [];
            for (_i = 0, _len = listener.length; _i < _len; _i++) {
              sublistener = listener[_i];
              this.listeners[key] = (_ref1 = this.listeners[key]) != null ? _ref1 : [];
              this.listeners[key].push(sublistener);
              _results1.push(this.context.addListener(event, sublistener));
            }
            return _results1;
          }).call(this));
        }
      }
      return _results;
    };

    Plugout.prototype.removeListeners = function(plugin) {

      /* removes all listeners from the given plugin */
      var event, key, listener, sublistener, _i, _len, _ref, _results;
      _ref = plugin.listeners;
      _results = [];
      for (event in _ref) {
        if (!__hasProp.call(_ref, event)) continue;
        listener = _ref[event];
        key = plugin.options.prefix + event;
        listener = this.listeners[key];
        if (typeof listener === 'function') {
          this.context.removeListener(event, listener);
        } else {
          for (_i = 0, _len = listener.length; _i < _len; _i++) {
            sublistener = listener[_i];
            this.context.removeListener(event, sublistener);
          }
        }
        _results.push(delete this.listeners[key]);
      }
      return _results;
    };

    Plugout.prototype.getPlugin = function(name) {

      /* returns the plugin object by name */
      var cleanName;
      cleanName = this.pluginPath + name;
      return this.plugins[cleanName];
    };

    Plugout.prototype.callPlugin = function() {
      var args, plugin, _ref;
      plugin = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];

      /* Calls a function provided by a plugin. The function should be defined in module.exports.provides */
      return (_ref = this.getPlugin(plugin)) != null ? _ref.call.apply(this, args) : void 0;
    };

    Plugout.prototype.loadPlugin = function(name, options) {

      /* Loads (or reloads) a plugin by name with the given options, attaches listeners and utility references. */
      var cleanName, full, module, pl, _base, _i, _len, _ref;
      cleanName = this.pluginPath + name;
      full = require.resolve(cleanName);
      pl = require.cache[full];
      if (pl != null) {
        if (pl.exports.reload != null) {
          _ref = pl.exports.reload;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            module = _ref[_i];
            delete require.cache[module];
          }
        }
        delete require.cache[full];
      }
      if (this.plugins[cleanName]) {
        this.unloadPlugin(name);
      }
      this.context.emit('plugin-pre-load', name);
      pl = require(full);
      this.plugins[cleanName] = pl;
      this.initPlugin(pl, name, options);
      this.addListeners(pl);
      this.context.emit('plugin-pre-init', name, pl);
      if (typeof (_base = pl.listeners).load === "function") {
        _base.load();
      }
      if (typeof pl.init === "function") {
        pl.init();
      }
      return this.context.emit('plugin-load', name, pl);
    };

    Plugout.prototype.initPlugin = function(pl, name, options) {
      var defaultOptions, _ref, _ref1, _ref2, _ref3;
      pl.context = this.context;
      pl.logger = (_ref = this.context.logger) != null ? _ref : null;
      if (pl.listeners == null) {
        pl.listeners = {};
      }
      if (pl.provides == null) {
        pl.provides = {};
      }
      defaultOptions = (_ref1 = (_ref2 = this.plugins) != null ? _ref2[name] : void 0) != null ? _ref1 : {};
      options = merge(defaultOptions, options != null ? options : {});
      pl.options = merge((_ref3 = pl.defaultOptions) != null ? _ref3 : {
        path: "/" + name
      }, options);
      pl.options.prefix = name;
      pl.getContext = (function(_this) {
        return function() {
          return _this.context;
        };
      })(this);
      pl.invoke = this.invoke;
      pl.provide = this.provide;
      pl.emit = this.context.emit;
      return pl.listen = this.context.addListener;
    };

    Plugout.prototype.unloadPlugin = function(name, options) {

      /* Unloads the given plugin. */
      var cleanName, pl, _base;
      cleanName = this.pluginPath + name;
      pl = this.plugins[cleanName];
      if (pl == null) {
        throw new Error("Plugin not found: " + name);
      }
      this.context.emit('plugin-pre-unload', name, pl);
      pl.options = options != null ? options : {};
      pl.options.prefix = name;
      this.removeListeners(pl);
      delete this.plugins[cleanName];
      if (typeof (_base = pl.listeners).unload === "function") {
        _base.unload();
      }
      return this.context.emit('plugin-unload', name, pl);
    };

    Plugout.prototype.loadPlugins = function(plugins) {

      /*
      Loads multiple plugins. Plugin list should be an object
      with the plugin names as keys and plugin option objects as values.
       */
      var name, options, _results;
      _results = [];
      for (name in plugins) {
        if (!__hasProp.call(plugins, name)) continue;
        options = plugins[name];
        _results.push(this.loadPlugin(name, options));
      }
      return _results;
    };

    Plugout.prototype.parseProvideName = function(name) {
      var matches, pl;
      matches = name.match(/^(([^.]+)\.)?(.*)/);
      pl = this.getPlugin(matches[2]);
      if (pl) {
        if (pl.provides == null) {
          pl.provides = {};
        }
      }
      return [pl, matches[3]];
    };

    Plugout.prototype.provide = function(name, fn) {
      var pl, subname, _ref;
      _ref = this.parseProvideName(name), pl = _ref[0], subname = _ref[1];
      if (pl != null) {
        return pl.provides[subname] = fn;
      } else {
        return this.provides[name] = fn;
      }
    };

    Plugout.prototype.invoke = function() {
      var args, fn, name, pl, _ref, _ref1, _ref2;
      fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.provides[fn] != null) {
        return this.provides[fn].apply(this, args);
      }
      _ref = this.parseProvideName(fn), pl = _ref[0], name = _ref[1];
      return pl != null ? (_ref1 = pl.provides) != null ? (_ref2 = _ref1[name]) != null ? _ref2.apply(pl, args) : void 0 : void 0 : void 0;
    };

    return Plugout;

  })();

  module.exports.Plugout = Plugout;

}).call(this);
